{
    "collab_server" : "",
    "contents" : "prediction_method <- function(data, y, verbose = FALSE, \n                              lag = NULL, message = NULL, pred_length = 16, pred_method=c('holt.winter',\n                                                                                          'stlf.arima',\n                                                                                          'stlf.ets',\n                                                                                          'seasonal.arima',\n                                                                                          'NN.NNAR','IB')) {\n  \n  pckg = c(\"lubridate\", \"dplyr\", \"quadprog\", \"forecast\")\n  \n  temp <- unlist(lapply(pckg, require, character.only=T))\n  \n  if (!all(temp==1) ) {\n    stop(\"This function relies on packages \\\"dtwclust\\\" \\\"ggplot2\\\" \\\"lubridate\\\" \\\"dplyr\\\" \\\"quadprog\\\" \\\"zoo\\\".\n         Use ?install.packages if they are not yet installed. \\n\")\n  }\n  \n  if (!all(temp==1) ) {\n    stop(\"This function relies on packages \\\"dtwclust\\\" \\\"ggplot2\\\" \\\"lubridate\\\" \\\"dplyr\\\" \\\"quadprog\\\" \\\"zoo\\\".\n         Use ?install.packages if they are not yet installed. \\n\")\n  }\n  \n  if(dim(data)[1] > dim(y)[1]*4.34524){\n    stop(\"Data quality issue: Install base has less data than Usage\")\n  }\n  \n  if(data[[1L]][1] < y[[1L]][1]){\n    stop(\"Data quality issue: the starting date of Usage is earlier than IB\")\n  }\n  \n  if(data[[1L]][dim(data)[1]] > y[[1L]][dim(y)[1]]){\n    stop(\"Data quality issue: the ending date of Usage is later than IB\")\n  }\n  \n  if(!is.data.frame(data)){\n    stop(\"data must be a single data frame.\")\n  } else {\n    if(ncol(data) != 2 || !is.numeric(data[[2]])){\n      stop(\"data must be a 2 column data.frame, with the first column being a set of timestamp, and the second coloumn being numeric values.\")\n    }\n    if (!(class(data[[1]])[1] == \"Date\")) {\n      stop(\"the first column being a set of timestamp.\")\n    }\n  }\n  \n  if(!is.data.frame(y)){\n    stop(\"data must be a single data frame.\")\n  } else {\n    if(ncol(y) != 2 || !is.numeric(y[[2]])){\n      stop(\"data must be a 2 column data.frame, with the first column being a set of timestamp, and the second coloumn being numeric values.\")\n    }\n    if (!(class(y[[1]])[1] == \"Date\")) {\n      stop(\"the first column being a set of timestamp.\")\n    }\n  }\n  \n  num_obs <- nrow(data)\n  \n  if(num_obs > 13 * 2){\n    num_obs_per_period = 13\n  } else if(num_obs > 4 * 2){\n    num_obs_per_period = 4\n  } else if(num_obs < 4 * 2){\n    stop(\"prediction needs at least 2 periods worth of data\")\n  }\n  \n  if(length(pred_method) != 1) {\n    stop(\"Pick only one of the following:\n         c(\\\"IB\\\", \\\"holt.winter\\\", \\\"stlf.arima\\\", \\\"stlf.ets\\\", \\\"seasonal.arima\\\", \\\"tslm.basic\\\", \\\"NN.NNAR\\\")\")\n  }\n  \n  #method IB\n  if(pred_method==\"IB\"){\n    lag_info <- lag\n    length <- dim(subset(y, y[[1L]]>=data[[1L]][1] & y[[1L]]<=data[[1L]][nrow(data)]))[1]\n    numbers <- dim(subset(y, y[[1L]]<data[[1L]][1]))[1] + 1\n    index <- numbers - lag_info\n    query <- reinterpolate(y[index:(length+index),][[2L]], dim(data)[1])\n    reference <- data[[2L]]\n    X2 <- cbind(query, 1)\n    results <- solve.QP(t(X2) %*% X2, t(reference) %*% X2, cbind(c(min(y[[2L]]), 1), c(1, 0)), c(0, 0))\n    y$baseline <- results$solution[2]+ results$solution[1]*y[[2L]]\n    timestamp_lag <- y[[1]]\n    month(timestamp_lag) <- month(timestamp_lag) + lag_info\n    y_transfer <- data.frame(timestamp=timestamp_lag, baseline=y$baseline)\n    \n    predicted_df <- data.frame(Date=seq(data[dim(data)[1], ][[1]]%m+%weeks(1), by = \"week\", length.out = pred_length), Magnitude=rep(0, pred_length))\n    \n    decop <- stl(ts(data[[2L]], frequency = num_obs_per_period), s.window = \"periodic\", robust = TRUE)\n    seasonal_req <- decop$time.series[,\"seasonal\"][1:num_obs_per_period]\n    req_len <- dim(data)[1]+pred_length\n    predicted_df$seaonal <- rep(seasonal_req, len=req_len)[(dim(data)[1]+1):req_len]\n    y_trim <- y_transfer[y_transfer[[1]] >= predicted_df[1,][[1]], ]\n    \n    interpo <- as.Date(tapply(as.character(predicted_df[[1]]), format(predicted_df[[1]], \"%Y-%m\"), min))\n    interpo_df <- data.frame(Date=interpo, Magnitude=rep(0, length(interpo)))\n    for(j in 1:length(interpo)){\n      for(i in 1:dim(y_trim)[1]){\n        if(format(y_trim[[1]], \"%Y-%m\")[i]==format(interpo[j], \"%Y-%m\")){\n          interpo_df[[2]][j] <- y_trim[[2]][i]\n        }\n      }\n    }\n    predicted_df[predicted_df[[1]] %in% interpo_df[[1]], ][[2]] <- interpo_df[[2]]\n    replaced <- predicted_df[(predicted_df[[2]] == 0), ]\n    \n    predicted_df[[2]] <- replace_outlier(predicted_df[, c(1,2)], replaced[, c(1,2)], replace_method=\"linear\")[[2]]\n    predicted_df[[2]] <- predicted_df[[2]] + predicted_df[[3]]\n    predicted_df <- predicted_df[, c(1,2)]\n  }\n  \n  else if(pred_method == \"holt.winter\"){\n    predicted_df <- data.frame(Date=seq(data[dim(data)[1], ][[1]]%m+%weeks(1), by = \"week\", length.out = pred_length), Magnitude=rep(0, pred_length))\n    s <- ts(data[[2L]], frequency = num_obs_per_period)\n    model <- HoltWinters(s)\n    fc <- forecast(model, h=pred_length)\n    predicted_df[[2]] <- fc$mean\n    y_transfer <- data.frame()\n  }\n  \n  else if(pred_method == \"stlf.arima\"){\n    predicted_df <- data.frame(Date=seq(data[dim(data)[1], ][[1]]%m+%weeks(1), by = \"week\", length.out = pred_length), Magnitude=rep(0, pred_length))\n    s <- ts(data[[2L]], frequency = num_obs_per_period)\n    fc <- stlf(s, h=pred_length, s.window = \"periodic\", method='arima', ic='bic')\n    predicted_df[[2]] <- fc$mean\n    y_transfer <- data.frame()\n  }\n  \n  else if(pred_method == \"stlf.ets\"){\n    predicted_df <- data.frame(Date=seq(data[dim(data)[1], ][[1]]%m+%weeks(1), by = \"week\", length.out = pred_length), Magnitude=rep(0, pred_length))\n    s <- ts(data[[2L]], frequency = num_obs_per_period)\n    fc <- stlf(s, h=pred_length, s.window = \"periodic\", method='ets', ic='bic', opt.crit='mae')\n    predicted_df[[2]] <- fc$mean\n    y_transfer <- data.frame()\n  }\n  \n  else if(pred_method == \"seasonal.arima\"){\n    predicted_df <- data.frame(Date=seq(data[dim(data)[1], ][[1]]%m+%weeks(1), by = \"week\", length.out = pred_length), Magnitude=rep(0, pred_length))\n    s <- ts(data[[2L]], frequency = num_obs_per_period)\n    model <- auto.arima(s, ic='bic', seasonal.test = 'ch')\n    fc <- forecast(model, h=pred_length)\n    predicted_df[[2]] <- fc$mean\n    y_transfer <- data.frame()\n  }\n  \n  else if(pred_method == \"NN.NNAR\"){\n    predicted_df <- data.frame(Date=seq(data[dim(data)[1], ][[1]]%m+%weeks(1), by = \"week\", length.out = pred_length), Magnitude=rep(0, pred_length))\n    s <- ts(data[[2L]], frequency = num_obs_per_period)\n    model <- nnetar(s)\n    fc <- forecast(model, h=pred_length)\n    predicted_df[[2]] <- fc$mean\n    y_transfer <- data.frame()\n  }\n  \n  return(list(pred = predicted_df, IB_trasfer = y_transfer)) \n  \n}",
    "created" : 1507539870001.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3439597791",
    "id" : "680F782",
    "lastKnownWriteTime" : 1507537548,
    "last_content_update" : 1507537548,
    "path" : "~/workspace/UsagePrediction/R/prediction_method.R",
    "project_path" : "R/prediction_method.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}